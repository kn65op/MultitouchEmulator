<?xml version="1.0"?>
<doc>
    <assembly>
        "MultitouchEmulator"
    </assembly>
    <members>
        <member name="M:ScreenShape.detectScreen(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Function that detects white screen on image from camera.
      @param image Image form camera

</member>
        <member name="T:ScreenShape">
Screen

</member>
        <member name="M:getScreenResolution">
Function returns screen resolution as cv::Size

</member>
        <member name="M:createStripesImage(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Size_&lt;System.Int32&gt;,System.Int32,System.Int32)">
Function creates image with stripes. Type of stripes are selected by number parameter

</member>
        <member name="M:createStripesImage(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32,System.Int32)">
Function creates image with stripes. Type of stripes are selected by number parameter

</member>
        <member name="M:subtractAbs(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This file contains functions for manipulating images 
Function that substrat two matrixes in grey scale and return matrix form 0 to 255;


Function that substrat two matrixes in grey scale and return matrix form 0 to 255;

</member>
        <member name="M:Homography.runHomography(cv.Mat,cv.Mat)">
            <summary>
ech
</summary>
        </member>
        <member name="T:Homography">
            <summary />
        </member>
        <member name="M:cv.Retina._convertCvMat2ValarrayBuffer(cv.Mat!System.Runtime.CompilerServices.IsConst,std.valarray&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">

 @param inputMatToConvert : the OpenCV cv::Mat that has to be converted to gray or RGB valarray buffer that will be processed by the retina model
 @param outputValarrayMatrix : the output valarray
 @return the input image color mode (color=true, gray levels=false)

</member>
        <member name="M:cv.Retina._convertValarrayBuffer2cvMat(std.valarray&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst,System.Boolean!System.Runtime.CompilerServices.IsConst,cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
exports a valarray buffer outing from HVStools objects to a cv::Mat in CV_8UC1 (gray level picture) or CV_8UC3 (color) format
@param grayMatrixToConvert the valarray to export to OpenCV
@param nbRows : the number of rows of the valarray flatten matrix
@param nbColumns : the number of rows of the valarray flatten matrix
@param colorMode : a flag which mentions if matrix is color (true) or graylevel (false)
@param outBuffer : the output matrix which is reallocated to satisfy Retina output buffer dimensions

</member>
        <member name="M:cv.Retina.activateContoursProcessing(System.Boolean!System.Runtime.CompilerServices.IsConst)">
Activate/desactivate the Parvocellular pathway processing (contours information extraction), by default, it is activated
@param activate: true if Parvocellular (contours information extraction) output should be activated, false if not

</member>
        <member name="M:cv.Retina.activateMovingContoursProcessing(System.Boolean!System.Runtime.CompilerServices.IsConst)">
Activate/desactivate the Magnocellular pathway processing (motion information extraction), by default, it is activated
@param activate: true if Magnocellular output should be activated, false if not

</member>
        <member name="M:cv.Retina.clearBuffers">
clear all retina buffers (equivalent to opening the eyes after a long period of eye close ;o)

</member>
        <member name="M:cv.Retina.setColorSaturation(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst)">
activate color saturation as the final step of the color demultiplexing process
-&gt; this saturation is a sigmoide function applied to each channel of the demultiplexed image.
@param saturateColors: boolean that activates color saturation (if true) or desactivate (if false)
@param colorSaturationValue: the saturation factor

</member>
        <member name="M:cv.Retina.getMagno(std.valarray&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
accessor of the motion channel of the retina (models peripheral vision)
@param retinaOutput_magno : the output buffer (reallocated if necessary), this output is the original retina filter model output, without any quantification or rescaling

</member>
        <member name="M:cv.Retina.getMagno(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
accessor of the motion channel of the retina (models peripheral vision)
@param retinaOutput_magno : the output buffer (reallocated if necessary), this output is rescaled for standard 8bits image processing use in OpenCV

</member>
        <member name="M:cv.Retina.getParvo(std.valarray&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
accessor of the details channel of the retina (models foveal vision)
@param retinaOutput_parvo : the output buffer (reallocated if necessary), this output is the original retina filter model output, without any quantification or rescaling

</member>
        <member name="M:cv.Retina.getParvo(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
accessor of the details channel of the retina (models foveal vision)
@param retinaOutput_parvo : the output buffer (reallocated if necessary), this output is rescaled for standard 8bits image processing use in OpenCV

</member>
        <member name="M:cv.Retina.run(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
method which allows retina to be applied on an input image, after run, encapsulated retina module is ready to deliver its outputs using dedicated acccessors, see getParvo and getMagno methods
@param inputImage : the input cv::Mat image to be processed, can be gray level or BGR coded in any format (from 8bit to 16bits)

</member>
        <member name="M:cv.Retina.setupIPLMagnoChannel(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst)">
set parameters values for the Inner Plexiform Layer (IPL) magnocellular channel
this channel processes signals outpint from OPL processing stage in peripheral vision, it allows motion information enhancement. It is decorrelated from the details channel. See reference paper for more details.
@param normaliseOutput : specifies if (true) output is rescaled between 0 and 255 of not (false)
@param parasolCells_beta: the low pass filter gain used for local contrast adaptation at the IPL level of the retina (for ganglion cells local adaptation), typical value is 0
@param parasolCells_tau: the low pass filter time constant used for local contrast adaptation at the IPL level of the retina (for ganglion cells local adaptation), unit is frame, typical value is 0 (immediate response)
@param parasolCells_k: the low pass filter spatial constant used for local contrast adaptation at the IPL level of the retina (for ganglion cells local adaptation), unit is pixels, typical value is 5
@param amacrinCellsTemporalCutFrequency: the time constant of the first order high pass fiter of the magnocellular way (motion information channel), unit is frames, tipicall value is 5
@param V0CompressionParameter: the compression strengh of the ganglion cells local adaptation output, set a value between 160 and 250 for best results, a high value increases more the low value sensitivity... and the output saturates faster, recommended value: 200
@param localAdaptintegration_tau: specifies the temporal constant of the low pas filter involved in the computation of the local "motion mean" for the local adaptation computation
@param localAdaptintegration_k: specifies the spatial constant of the low pas filter involved in the computation of the local "motion mean" for the local adaptation computation

</member>
        <member name="M:cv.Retina.setupOPLandIPLParvoChannel(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Boolean!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst)">
setup the OPL and IPL parvo channels (see biologocal model)
OPL is referred as Outer Plexiform Layer of the retina, it allows the spatio-temporal filtering which withens the spectrum and reduces spatio-temporal noise while attenuating global luminance (low frequency energy)
IPL parvo is the OPL next processing stage, it refers to Inner Plexiform layer of the retina, it allows high contours sensitivity in foveal vision.
for more informations, please have a look at the paper Benoit A., Caplier A., Durette B., Herault, J., "USING HUMAN VISUAL SYSTEM MODELING FOR BIO-INSPIRED LOW LEVEL IMAGE PROCESSING", Elsevier, Computer Vision and Image Understanding 114 (2010), pp. 758-773, DOI: http://dx.doi.org/10.1016/j.cviu.2010.01.011
@param colorMode : specifies if (true) color is processed of not (false) to then processing gray level image
@param normaliseOutput : specifies if (true) output is rescaled between 0 and 255 of not (false)
@param photoreceptorsLocalAdaptationSensitivity: the photoreceptors sensitivity renage is 0-1 (more log compression effect when value increases)
@param photoreceptorsTemporalConstant: the time constant of the first order low pass filter of the photoreceptors, use it to cut high temporal frequencies (noise or fast motion), unit is frames, typical value is 1 frame
@param photoreceptorsSpatialConstant: the spatial constant of the first order low pass filter of the photoreceptors, use it to cut high spatial frequencies (noise or thick contours), unit is pixels, typical value is 1 pixel
@param horizontalCellsGain: gain of the horizontal cells network, if 0, then the mean value of the output is zero, if the parameter is near 1, then, the luminance is not filtered and is still reachable at the output, typicall value is 0
@param HcellsTemporalConstant: the time constant of the first order low pass filter of the horizontal cells, use it to cut low temporal frequencies (local luminance variations), unit is frames, typical value is 1 frame, as the photoreceptors
@param HcellsSpatialConstant: the spatial constant of the first order low pass filter of the horizontal cells, use it to cut low spatial frequencies (local luminance), unit is pixels, typical value is 5 pixel, this value is also used for local contrast computing when computing the local contrast adaptation at the ganglion cells level (Inner Plexiform Layer parvocellular channel model)
@param ganglionCellsSensitivity: the compression strengh of the ganglion cells local adaptation output, set a value between 160 and 250 for best results, a high value increases more the low value sensitivity... and the output saturates faster, recommended value: 230

</member>
        <member name="M:cv.Retina.write(cv.FileStorage*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
write xml/yml formated parameters information
@param fs : a cv::Filestorage object ready to be filled

</member>
        <member name="M:cv.Retina.write(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;)">
write xml/yml formated parameters information
@rparam fs : the filename of the xml file that will be open and writen with formatted parameters information

</member>
        <member name="M:cv.Retina.printSetup">
parameters setup display method
@return a string which contains formatted parameters information

</member>
        <member name="T:cv.Retina.RetinaParameters">
@return the current parameters setup

</member>
        <member name="M:cv.Retina.setup(cv.Retina.RetinaParameters)">
	 * try to open an XML retina parameters file to adjust current retina instance setup
	 * =&gt; if the xml file does not exist, then default setup is applied
	 * =&gt; warning, Exceptions are thrown if read XML file is not valid
	 * @param newParameters : a parameters structures updated with the new target configuration
         * @param applyDefaultSetupOnFailure : set to true if an error must be thrown on error

</member>
        <member name="M:cv.Retina.setup(cv.FileStorage*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean!System.Runtime.CompilerServices.IsConst)">
	 * try to open an XML retina parameters file to adjust current retina instance setup
	 * =&gt; if the xml file does not exist, then default setup is applied
	 * =&gt; warning, Exceptions are thrown if read XML file is not valid
	 * @param fs : the open Filestorage which contains retina parameters
         * @param applyDefaultSetupOnFailure : set to true if an error must be thrown on error

</member>
        <member name="M:cv.Retina.setup(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,System.Boolean!System.Runtime.CompilerServices.IsConst)">
	 * try to open an XML retina parameters file to adjust current retina instance setup
	 * =&gt; if the xml file does not exist, then default setup is applied
	 * =&gt; warning, Exceptions are thrown if read XML file is not valid
	 * @param retinaParameterFile : the parameters filename
         * @param applyDefaultSetupOnFailure : set to true if an error must be thrown on error

</member>
        <member name="M:cv.Retina.outputSize">
retreive retina output buffer size 

</member>
        <member name="M:cv.Retina.inputSize">
retreive retina input buffer size 

</member>
        <member name="M:cv.Retina.#ctor(cv.Size_&lt;System.Int32&gt;,System.Boolean!System.Runtime.CompilerServices.IsConst,cv.RETINA_COLORSAMPLINGMETHOD,System.Boolean!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
	 * Complete Retina filter constructor which allows all basic structural parameters definition
         * @param inputSize : the input frame size
	 * @param colorMode : the chosen processing mode : with or without color processing
	 * @param colorSamplingMethod: specifies which kind of color sampling will be used
	 * @param useRetinaLogSampling: activate retina log sampling, if true, the 2 following parameters can be used
	 * @param reductionFactor: only usefull if param useRetinaLogSampling=true, specifies the reduction factor of the output frame (as the center (fovea) is high resolution and corners can be underscaled, then a reduction of the output is allowed without precision leak
	 * @param samplingStrenght: only usefull if param useRetinaLogSampling=true, specifies the strenght of the log scale that is applied

</member>
        <member name="M:cv.Retina.#ctor(cv.Size_&lt;System.Int32&gt;)">
Main constructor with most commun use setup : create an instance of color ready retina model
@param inputSize : the input frame size

</member>
        <member name="T:cv.Retina">
 @class Retina a wrapper class which allows the Gipsa/Listic Labs model to be used.
 This retina model allows spatio-temporal image processing (applied on still images, video sequences).
 As a summary, these are the retina model properties:
 =&gt; It applies a spectral whithening (mid-frequency details enhancement)
 =&gt; high frequency spatio-temporal noise reduction
 =&gt; low frequency luminance to be reduced (luminance range compression)
 =&gt; local logarithmic luminance compression allows details to be enhanced in low light conditions

 USE : this model can be used basically for spatio-temporal video effects but also for :
      _using the getParvo method output matrix : texture analysiswith enhanced signal to noise ratio and enhanced details robust against input images luminance ranges
      _using the getMagno method output matrix : motion analysis also with the previously cited properties

 for more information, reer to the following papers :
 Benoit A., Caplier A., Durette B., Herault, J., "USING HUMAN VISUAL SYSTEM MODELING FOR BIO-INSPIRED LOW LEVEL IMAGE PROCESSING", Elsevier, Computer Vision and Image Understanding 114 (2010), pp. 758-773, DOI: http://dx.doi.org/10.1016/j.cviu.2010.01.011
 Vision: Images, Signals and Neural Networks: Models of Neural Processing in Visual Perception (Progress in Neural Processing),By: Jeanny Herault, ISBN: 9814273686. WAPI (Tower ID): 113266891.

 The retina filter includes the research contributions of phd/research collegues from which code has been redrawn by the author :
 _take a look at the retinacolor.hpp module to discover Brice Chaix de Lavarene color mosaicing/demosaicing and the reference paper:
 ====&gt; B. Chaix de Lavarene, D. Alleysson, B. Durette, J. Herault (2007). "Efficient demosaicing through recursive filtering", IEEE International Conference on Image Processing ICIP 2007
 _take a look at imagelogpolprojection.hpp to discover retina spatial log sampling which originates from Barthelemy Durette phd with Jeanny Herault. A Retina / V1 cortex projection is also proposed and originates from Jeanny's discussions.
 ====&gt; more informations in the above cited Jeanny Heraults's book.

</member>
        <member name="M:cv.LogPolar_Adjacent.Dispose">
Destructor

</member>
        <member name="M:cv.LogPolar_Adjacent.to_cartesian(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Transformation from cortical image to retinal (inverse log-polar) image.
\param source the cortical image
\return the transformed image (retinal image)

</member>
        <member name="M:cv.LogPolar_Adjacent.to_cortical(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Transformation from Cartesian image to cortical (log-polar) image.
\param source the Cartesian image
\return the transformed image (cortical image)

</member>
        <member name="M:cv.LogPolar_Adjacent.#ctor(System.Int32,System.Int32,cv.Point_&lt;System.Int32&gt;,System.Int32,System.Double,System.Double,System.Int32,System.Int32,System.Int32)">
Constructor
\param w the width of the input image
\param h the height of the input image
\param center the transformation center: where the output precision is maximal
\param R the number of rings of the cortical image (default value 70 pixel)
\param ro0 the radius of the blind spot (default value 3 pixel)
\param smin the size of the subpixel (default value 0.25 pixel)
\param full \a 1 (default value) means that the retinal image (the inverse transform) is computed within the circumscribing circle. 
            \a 0 means that the retinal image is computed within the inscribed circle.
\param S the number of sectors of the cortical image (default value 70 pixel).
         Its value is usually internally computed to obtain a pixel aspect ratio equals to 1.
\param sp \a 1 (default value) means that the parameter \a S is internally computed. 
          \a 0 means that the parameter \a S is provided by the user.

</member>
        <member name="T:cv.LogPolar_Adjacent">
 Adjacent receptive fields technique

All the Cartesian pixels, whose coordinates in the cortical domain share the same integer part, are assigned to the same RF.
The precision of the boundaries of the RF can be improved by breaking each pixel into subpixels and assigning each of them to the correct RF.
This technique is implemented from: Traver, V., Pla, F.: Log-polar mapping template design: From task-level requirements
to geometry parameters. Image Vision Comput. 26(10) (2008) 1354-1370

More details can be found in http://dx.doi.org/10.1007/978-3-642-23968-7_5

</member>
        <member name="M:cv.LogPolar_Overlapping.Dispose">
Destructor

</member>
        <member name="M:cv.LogPolar_Overlapping.to_cartesian(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Transformation from cortical image to retinal (inverse log-polar) image.
\param source the cortical image
\return the transformed image (retinal image)

</member>
        <member name="M:cv.LogPolar_Overlapping.to_cortical(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Transformation from Cartesian image to cortical (log-polar) image.
\param source the Cartesian image
\return the transformed image (cortical image)

</member>
        <member name="M:cv.LogPolar_Overlapping.#ctor(System.Int32,System.Int32,cv.Point_&lt;System.Int32&gt;,System.Int32,System.Double,System.Int32,System.Int32,System.Int32)">
Constructor
\param w the width of the input image
\param h the height of the input image
\param center the transformation center: where the output precision is maximal
\param R the number of rings of the cortical image (default value 70 pixel)
\param ro0 the radius of the blind spot (default value 3 pixel)
\param full \a 1 (default value) means that the retinal image (the inverse transform) is computed within the circumscribing circle. 
            \a 0 means that the retinal image is computed within the inscribed circle.
\param S the number of sectors of the cortical image (default value 70 pixel).
         Its value is usually internally computed to obtain a pixel aspect ratio equals to 1.
\param sp \a 1 (default value) means that the parameter \a S is internally computed. 
          \a 0 means that the parameter \a S is provided by the user.

</member>
        <member name="T:cv.LogPolar_Overlapping">
Overlapping circular receptive fields technique

The Cartesian plane is divided in two regions: the fovea and the periphery.
The fovea (oversampling) is handled by using the bilinear interpolation technique described above, whereas in
the periphery we use the overlapping Gaussian circular RFs.

More details can be found in http://dx.doi.org/10.1007/978-3-642-23968-7_5

</member>
        <member name="M:cv.LogPolar_Interp.Dispose">
Destructor

</member>
        <member name="M:cv.LogPolar_Interp.to_cartesian(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Transformation from cortical image to retinal (inverse log-polar) image.
\param source the cortical image
\return the transformed image (retinal image)

</member>
        <member name="M:cv.LogPolar_Interp.to_cortical(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Transformation from Cartesian image to cortical (log-polar) image.
\param source the Cartesian image
\return the transformed image (cortical image)

</member>
        <member name="M:cv.LogPolar_Interp.#ctor(System.Int32,System.Int32,cv.Point_&lt;System.Int32&gt;,System.Int32,System.Double,System.Int32,System.Int32,System.Int32,System.Int32)">
Constructor
\param w the width of the input image
\param h the height of the input image
\param center the transformation center: where the output precision is maximal
\param R the number of rings of the cortical image (default value 70 pixel)
\param ro0 the radius of the blind spot (default value 3 pixel)
\param full \a 1 (default value) means that the retinal image (the inverse transform) is computed within the circumscribing circle. 
            \a 0 means that the retinal image is computed within the inscribed circle.
\param S the number of sectors of the cortical image (default value 70 pixel).
         Its value is usually internally computed to obtain a pixel aspect ratio equals to 1.
\param sp \a 1 (default value) means that the parameter \a S is internally computed. 
          \a 0 means that the parameter \a S is provided by the user.

</member>
        <member name="T:cv.LogPolar_Interp">
Bilinear interpolation technique.

The value of a desired cortical pixel is obtained through a bilinear interpolation of the values
of the four nearest neighbouring Cartesian pixels to the center of the RF.
The same principle is applied to the inverse transformation.

More details can be found in http://dx.doi.org/10.1007/978-3-642-23968-7_5

</member>
        <member name="M:cv.linemod.getDefaultLINEMOD">
 \brief Factory function for detector using LINE-MOD algorithm with color gradients
 and depth normals.

 Default parameter settings suitable for VGA images.

</member>
        <member name="M:cv.linemod.getDefaultLINE">
 \brief Factory function for detector using LINE algorithm with color gradients.

 Default parameter settings suitable for VGA images.

</member>
        <member name="M:cv.linemod.Detector.getTemplates(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
 \brief Get the template pyramid identified by template_id.

 For example, with 2 modalities (Gradient, Normal) and two pyramid levels
 (L0, L1), the order is (GradientL0, NormalL0, GradientL1, NormalL1).

</member>
        <member name="M:cv.linemod.Detector.pyramidLevels">
\brief Get number of pyramid levels used by this detector.

</member>
        <member name="M:cv.linemod.Detector.getT(System.Int32)">
\brief Get sampling step T at pyramid_level.

</member>
        <member name="M:cv.linemod.Detector.getModalities">
 \brief Get the modalities used by this detector.

 You are not permitted to add/remove modalities, but you may dynamic_cast them to
 tweak parameters.

</member>
        <member name="M:cv.linemod.Detector.addSyntheticTemplate(std.vector&lt;cv.linemod.Template&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Add a new object template computed by external means.

</member>
        <member name="M:cv.linemod.Detector.addTemplate(std.vector&lt;cv.Mat&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Rect_&lt;System.Int32&gt;*)">
 \brief Add new object template.

 \param      sources      Source images, one for each modality.
 \param      class_id     Object class ID.
 \param      object_mask  Mask separating object from background.
 \param[out] bounding_box Optionally return bounding box of the extracted features.

 \return Template ID, or -1 if failed to extract a valid template.

</member>
        <member name="M:cv.linemod.Detector.#ctor(std.vector&lt;cv.Ptr&lt;cv.linemod.Modality&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 \brief Constructor.

 \param modalities       Modalities to use (color gradients, depth normals, ...).
 \param T_pyramid        Value of the sampling step T at each pyramid level. The
                         number of pyramid levels is T_pyramid.size().

</member>
        <member name="M:cv.linemod.Detector.#ctor">
\brief Empty constructor, initialize with read().

</member>
        <member name="T:cv.linemod.Detector">
\brief Object detector using the LINE template matching algorithm with any set of
modalities.

</member>
        <member name="M:cv.linemod.Match.op_LessThan(cv.linemod.Match!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sort matches with high similarity to the front
</member>
        <member name="T:cv.linemod.Match">
\brief Represents a successful template match.

</member>
        <member name="M:cv.linemod.colormap(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Debug function to colormap a quantized image for viewing.

</member>
        <member name="M:cv.linemod.DepthNormal.#ctor(System.Int32,System.Int32,System.UInt32,System.Int32)">
 \brief Constructor.

 \param distance_threshold   Ignore pixels beyond this distance.
 \param difference_threshold When computing normals, ignore contributions of pixels whose
                             depth difference with the central pixel is above this threshold.
 \param num_features         How many features a template must contain.
 \param extract_threshold    Consider as candidate feature only if there are no differing
                             orientations within a distance of extract_threshold.

</member>
        <member name="M:cv.linemod.DepthNormal.#ctor">
\brief Default constructor. Uses reasonable default parameter values.

</member>
        <member name="T:cv.linemod.DepthNormal">
\brief Modality that computes quantized surface normals from a dense depth map.

</member>
        <member name="M:cv.linemod.ColorGradient.#ctor(System.Single,System.UInt32,System.Single)">
 \brief Constructor.

 \param weak_threshold   When quantizing, discard gradients with magnitude less than this.
 \param num_features     How many features a template must contain.
 \param strong_threshold Consider as candidate features only gradients whose norms are
                         larger than this.

</member>
        <member name="M:cv.linemod.ColorGradient.#ctor">
\brief Default constructor. Uses reasonable default parameter values.

</member>
        <member name="T:cv.linemod.ColorGradient">
\brief Modality that computes quantized gradient orientations from a color image.

</member>
        <member name="M:cv.linemod.Modality.create(cv.FileNode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Load a modality from file.

</member>
        <member name="M:cv.linemod.Modality.create(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 \brief Create modality by name.

 The following modality types are supported:
 - "ColorGradient"
 - "DepthNormal"

</member>
        <member name="M:cv.linemod.Modality.process(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 \brief Form a quantized image pyramid from a source image.

 \param[in] src  The source image. Type depends on the modality.
 \param[in] mask Optional mask. If not empty, unmasked pixels are set to zero
                 in quantized image and cannot be extracted as features.

</member>
        <member name="T:cv.linemod.Modality">
 \brief Interface for modalities that plug into the LINE template matching representation.

 \todo Max response, to allow optimization of summing (255/MAX) features as uint8

</member>
        <member name="M:cv.linemod.QuantizedPyramid.selectScatteredFeatures(std.vector&lt;cv.linemod.QuantizedPyramid.Candidate&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.linemod.Feature&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Single)">
 \brief Choose candidate features so that they are not bunched together.

 \param[in]  candidates   Candidate features sorted by score.
 \param[out] features     Destination vector of selected features.
 \param[in]  num_features Number of candidates to select.
 \param[in]  distance     Hint for desired distance between features.

</member>
        <member name="M:cv.linemod.QuantizedPyramid.Candidate.op_LessThan(cv.linemod.QuantizedPyramid.Candidate!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sort candidates with high score to the front
</member>
        <member name="T:cv.linemod.QuantizedPyramid.Candidate">
Candidate feature with a score
</member>
        <member name="M:cv.linemod.QuantizedPyramid.pyrDown">
 \brief Go to the next pyramid level.

 \todo Allow pyramid scale factor other than 2

</member>
        <member name="M:cv.linemod.QuantizedPyramid.extractTemplate(cv.linemod.Template*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 \brief Extract most discriminant features at current pyramid level to form a new template.

 \param[out] templ The new template.

</member>
        <member name="M:cv.linemod.QuantizedPyramid.quantize(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 \brief Compute quantized image at current pyramid level for online detection.

 \param[out] dst The destination 8-bit image. For each pixel at most one bit is set,
                 representing its classification.

</member>
        <member name="T:cv.linemod.QuantizedPyramid">
\brief Represents a modality operating over an image pyramid.

</member>
        <member name="T:cv.linemod.Feature">
@todo Convert doxy comments to rst
\brief Discriminant feature described by its location and label.

</member>
        <member name="M:cv.Hamming.op_FunctionCall(System.Byte!System.Runtime.CompilerServices.IsConst*,System.Byte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
this will count the bits in a ^ b

</member>
        <member name="M:cv.BriefDescriptorExtractor.info">
@todo read and write for brief
</member>
        <member name="T:cv.StarAdjuster">
An adjuster for StarFeatureDetector, this one adjusts the responseThreshold for now
 * TODO find a faster way to converge the parameters for Star - use CvStarDetectorParams

</member>
        <member name="M:cv.FastAdjuster.#ctor(System.Int32,System.Boolean,System.Int32,System.Int32)">
\param init_thresh the initial threshold to start with, default = 20
     * \param nonmax whether to use non max or not for fast feature detection

</member>
        <member name="T:cv.FastAdjuster">
\brief an adjust for the FAST detector. This will basically decrement or increment the
 * threshold by 1

</member>
        <member name="M:cv.DynamicAdaptedFeatureDetector.#ctor(cv.Ptr&lt;cv.AdjusterAdapter&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)">
\param adjaster an AdjusterAdapter that will do the detection and parameter adjustment
     *  \param max_features the maximum desired number of features
     *  \param max_iters the maximum number of times to try to adjust the feature detector params
     * 			for the FastAdjuster this can be high, but with Star or Surf this can get time consuming
     *  \param min_features the minimum desired features

</member>
        <member name="M:cv.AdjusterAdapter.good">
are params maxed out or still valid?
     * \return false if the parameters can't be adjusted any more

</member>
        <member name="M:cv.AdjusterAdapter.tooMany(System.Int32,System.Int32)">
too many features were detected so, adjust the detector params accordingly
     * \param max the maximum number of desired features
     * \param n_detected the number previously detected

</member>
        <member name="M:cv.AdjusterAdapter.tooFew(System.Int32,System.Int32)">
too few features were detected so, adjust the detector params accordingly
     * \param min the minimum number of desired features
     * \param n_detected the number previously detected

</member>
        <member name="M:cv.AdjusterAdapter.Dispose">
pure virtual interface

</member>
        <member name="T:cv.AdjusterAdapter">
\brief A feature detector parameter adjuster, this is used by the DynamicAdaptedFeatureDetector
 *  and is a wrapper for FeatureDetector that allow them to be adjusted after a detection

</member>
        <member name="M:cvSetIdentity(System.Void*,CvScalar)">
* Finds selected eigen values and vectors of a symmetric matrix */
</member>
        <!-- Discarding badly formed XML document comment for member 'M:cv.op_LeftShift(std.basic_ostream<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.op_LeftShift(std.basic_ostream<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Formatted!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.DynamicAdaptedFeatureDetector'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.linemod.Detector.match(std.vector<cv.Mat>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,std.vector<cv.linemod.Match>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<cv.Mat>!System.Runtime.CompilerServices.IsCon'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.op_LeftShift(std.basic_ostream<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.op_LeftShift(std.basic_ostream<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Formatted!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.DynamicAdaptedFeatureDetector'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.linemod.Detector.match(std.vector<cv.Mat>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,std.vector<cv.linemod.Match>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<cv.Mat>!System.Runtime.CompilerServices.IsCon'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.op_LeftShift(std.basic_ostream<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.op_LeftShift(std.basic_ostream<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Formatted!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.DynamicAdaptedFeatureDetector'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.linemod.Detector.match(std.vector<cv.Mat>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,std.vector<cv.linemod.Match>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<cv.Mat>!System.Runtime.CompilerServices.IsCon'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.op_LeftShift(std.basic_ostream<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.op_LeftShift(std.basic_ostream<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Formatted!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.DynamicAdaptedFeatureDetector'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.linemod.Detector.match(std.vector<cv.Mat>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,std.vector<cv.linemod.Match>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<cv.Mat>!System.Runtime.CompilerServices.IsCon'. -->
    </members>
</doc>